---
layout: single
title:  "알고리즘 공부"
---

# 알고리즘

## 개요

- 목적을 달성하기위한 절차/행동(규칙)
- 문제를 해결하는 절차

## 시간복잡도

- BigO O(N) O(N^2) O(log N)

js, python은 배열 사이즈를 자동으로 핸들링해줘서 선언할필요없음

Array - 조회, 맨뒤 값 추가/삭제는 좋지만 검색, 추가, 삭제는 느림

- 검색
  - 선형검색 알고리즘
    - 순차검색 느림, 찾는정보가 없을땐 최악
  - 이진검색 알고리즘
    - 정렬된 배열에서만사용가능
    - 가운데값을 기준으로 검색 데이터가 많아질수록 성형검색 대비 기하급수적으로 빨라짐

- 정렬
  - 버블정렬
    - 1,2 비교 정렬 2,3 정렬 계속 반복하고 처음부터 다시시작
    - O(N^2)
  - 선택정렬
    - 전채 검색하여 제일작은수 찾아서 맨앞으로
    - O(N^2)
  - 삽입정렬
    - 1,2 비교 정렬 3번값을 1,2비교 정렬 4번값을 1,2,3 비교 정렬
    - O(N^2)
  - 셀정렬
    - 삽입정렬을 보완, 구간별 삽입 정렬
    - 16개 정수일때 16/2 구간을 나누어 정렬 이후 8/2 구간  4/2 구간 까지 정렬 후 최종적으로 삽입정렬을 함으로써 정렬됨
    - 마지막 삽입정렬을 위해 어느정도 정렬을 하는 알고리즘
    - O(N^1.5)
  - 퀵정렬
    - 이진검색 비슷
    - 아무값을 기준으로 작으면 왼쪽 크면 오른쪽 정렬 완료되면 작은쪽의 가운데값을 잡아서
또 작은건 왼쪽 큰거는 오른쪽 O(N log N) 시작점 끝점에 포인터를 잡아 조건에맞는것만 스왚
    - 가장빠른 정렬
  - 힙정렬
    - 이진트리를 이용한 정렬 맨위 부모노드는 값을 크게학고 자식노드는 작게
    - 붕괴가 일어나면 힙생성 알고리즘 수행하면
    - 배열이 필요없다는점에서 메모리 낭비없다는 장점있음
    - O(N log N)
  - 병합정렬
    - 모든데이터를 쪼개서 정렬하며 합침(8개면 1->2->4->8)
    - O(N log N)
  - 기수정렬
    - 1, 10, 100 단위의 기초가되는 수를 기수라함, 자리수별로 계수정렬 O(N)
  - 계수정렬 - 크기별로 카운트를 하고 순서대로 카운트만큼 증가시킴 O(N) 데이터의 크기가 한정될 경우 아주빠르게 처리

선택,삽입은 DB알고리즘에 좋음

![시간복잡도 비교](/assets/img/complex.png)

해시테이블 - O(1) 사용방법 key, value  ->  "목표값", true 로 저장 존재확인

ADT - 추상적 자료 구조 (큐, 스택)
